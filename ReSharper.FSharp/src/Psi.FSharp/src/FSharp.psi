options {
  parserPackage="JetBrains.ReSharper.Psi.FSharp.Gen";
  parserClassName="FSharpParserGenerated";
  psiInterfacePackageName="JetBrains.ReSharper.Psi.FSharp.Tree";
  psiStubsPackageName="JetBrains.ReSharper.Psi.FSharp.Impl.Tree";
  psiStubsBaseClass="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpCompositeElement";
  tokenClassName="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpToken";
  tokenTypePackageName="JetBrains.ReSharper.Psi.FSharp.Parsing";
  tokenTypeClassName="FSharpTokenType";
  parserTargetSubdir="Parsing/FSharp";
  psiInterfacesTargetSubdir="Psi/FSharp";
  psiStubsTargetSubdir="Psi/FSharp/Impl";
  elementTypePrefix="";
  visitorClassName="TreeNodeVisitor";
  visitorMethodSuffix="";
  disableReflection;
  separateHierarchies;
  acceptModifier="";
  visitorSuperClassName="JetBrains.ReSharper.Psi.FSharp.TreeNodeVisitorBase";
  "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
  "leafElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpLeafElement";
  "compositeElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpCompositeElement";
  "psiElementVisitorClassFQName"="JetBrains.ReSharper.Psi.FSharp.Tree.TreeNodeVisitor";
  "unexpectedTokenClassFQName"="Parsing.UnexpectedToken";
  "syntaxErrorClassFQName"="Parsing.SyntaxError";
  "parserGenRuntimePackageName"="Parsing";
  "createTokenElementMethodFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Factory.createTokenElement";
  "visitMethodPrefix"="Visit";
  "lexerClassName"="JetBrains.ReSharper.Psi.FSharp.Parsing.FSharpLexer";
  "psiClassesPrefix"="";
  "psiElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Tree.IFSharpTreeNode";
  customImplPackage="JetBrains.ReSharper.Psi.FSharp.Impl.Tree";
  customInterfacePackage="JetBrains.ReSharper.Psi.FSharp.Tree";
  "interfaceNamePrefix"="I";
  "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
  "customImplSuffix"="";
  "objectClassFQName"="System.Object";
  publicChildRolePrefix="FS_";
  tokenBitsetThreshold=4;
  elementTypeBaseClass="JetBrains.ReSharper.Psi.FSharp.Tree.FSharpCompositeNodeType";
  parserMessagesClass="JetBrains.ReSharper.Psi.FSharp.Parsing.ParserMessages";
  generateWorkingPsi;
}



// Files

interface fSharpFile
:
  fSharpImplFile |
  fSharpSigFile
;

fSharpImplFile options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpFileBase";
}
:
  topLevelModuleOrNamespaceDeclaration<MODULE_OR_NAMESPACE_DECLARATION, Declarations>*
  fakeSeparator
;

fSharpSigFile options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpFileBase";
}
:
  moduleOrNamespaceSignature<MODULE_OR_NAMESPACE_SIGNATURE, Signatures>*
  fakeSeparator
;



// Modules and namespaces

interface fSharpDeclaration
:
  moduleLikeDeclaration |
  moduleMemberDeclaration |
  fSharpTypeDeclaration
;

interface moduleLikeDeclaration
:
  topLevelModuleOrNamespaceDeclaration |
  nestedModuleDeclaration
;

interface topLevelModuleOrNamespaceDeclaration
:
  topLevelModuleDeclaration |
  fSharpNamespaceDeclaration
;

fSharpNamespaceDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpCachedDeclarationBase";
}
:
  longIdentifier<LONG_IDENTIFIER, LongIdentifier>
  moduleMember<MODULE_MEMBER, Members>*
  fakeSeparator
;

topLevelModuleDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  longIdentifier<LONG_IDENTIFIER, LongIdentifier>
  moduleMember<MODULE_MEMBER, Members>*
  fakeSeparator
;

moduleOrNamespaceSignature : fakeSeparator;



// Module members

interface moduleMember
:
  moduleMemberDeclaration |
  moduleMemberStatement |
  otherModuleMember
;

interface moduleMemberDeclaration
:
  nestedModuleDeclaration |
  fSharpTypeDeclaration |
  otherMemberDeclaration
;

interface moduleMemberStatement
:
  open |
  do
;

nestedModuleDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  moduleMember<MODULE_MEMBER, Members>*
  fakeSeparator
;

interface fSharpTypeDeclaration
:
  fSharpExceptionDeclaration |
  fSharpSimpleTypeDeclaration |
  fSharpObjectModelTypeDeclaration
;

interface fSharpSimpleTypeDeclaration
:
  fSharpEnumDeclaration |
  fSharpRecordDeclaration |
  fSharpUnionDeclaration |
  fSharpNotCompiledTypeDeclaration
;

interface fSharpNotCompiledTypeDeclaration
:
  fSharpTypeAbbreviationDeclaration |
  fSharpAbstractTypeDeclaration |
  fSharpOtherSimpleTypeDeclaration
;

interface fSharpObjectModelTypeDeclaration
:
  fSharpClassDeclaration |
  fSharpInterfaceDeclaration |
  fSharpStructDeclaration |
  fSharpUnspecifiedObjectTypeDeclaration
;



// Enums

fSharpEnumDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
//  (fSharpEnumMemberDeclaration<FS_ENUM_MEMBER, EnumMemberDeclarations>)* fakeSeparator
;

//fSharpEnumMemberDeclaration options {
//  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
//}
//:
//  fSharpIdentifier<IDENTIFIER, Identifier>
//;



// Records

fSharpRecordDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
//  (fSharpFieldDeclaration<FS_FIELD, Fields>)* fakeSeparator
//  (fSharpTypeMemberDeclaration<TYPE_MEMBER, Members>)* fakeSeparator
;



// Discriminated unions

fSharpUnionDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  fSharpUnionCaseDeclaration<UNION_CASE, Cases>* fakeSeparator
//  (fSharpTypeMemberDeclaration<TYPE_MEMBER, Members>)* fakeSeparator
;

interface fSharpUnionCaseDeclaration
:
//  fSharpSingletonUnionCaseDeclaration |
  fSharpTypedUnionCaseDeclaration
;

//fSharpSingletonUnionCaseDeclaration options {
//  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
//}
//:
//  fSharpIdentifier<IDENTIFIER, Identifier>
//;

fSharpTypedUnionCaseDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpIdentifier<IDENTIFIER, Identifier>
//  (fSharpReadOnlyFieldDeclaration<FS_FIELD, Fields>)* fakeSeparator
;



// Other members

fSharpExceptionDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
;

fSharpTypeAbbreviationDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
;

otherMemberDeclaration
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
;

fSharpOtherSimpleTypeDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
;

fSharpAbstractTypeDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
;


// Object model type declarations

fSharpClassDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  (fSharpAttribute<ATTRIBUTE, Attributes>)* fakeSeparator
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  (fSharpTypeMemberDeclaration<TYPE_MEMBER, Members>)* fakeSeparator
;

fSharpInterfaceDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  (fSharpAttribute<ATTRIBUTE, Attributes>)* fakeSeparator
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  (fSharpTypeMemberDeclaration<TYPE_MEMBER, Members>)* fakeSeparator
;

fSharpStructDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  (fSharpAttribute<ATTRIBUTE, Attributes>)* fakeSeparator
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  (fSharpTypeMemberDeclaration<TYPE_MEMBER, Members>)* fakeSeparator
;

fSharpUnspecifiedObjectTypeDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  (fSharpAttribute<ATTRIBUTE, Attributes>)* fakeSeparator
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  (fSharpTypeMemberDeclaration<TYPE_MEMBER, Members>)* fakeSeparator
;

interface fSharpTypeMemberDeclaration
:
  typeInherit |
  interfaceImplementation |
  interfaceInherit |
  abstractSlot |
  
//  memberDeclaration |
//  implicitCtor |
//  letBindings |
//  valField |
//  autoProperty |

  otherTypeMember
;

interfaceInherit : longIdentifier<LONG_IDENTIFIER, LongIdentifier> fakeSeparator;
typeInherit : longIdentifier<LONG_IDENTIFIER, LongIdentifier> fakeSeparator;
interfaceImplementation : longIdentifier<LONG_IDENTIFIER, LongIdentifier> fakeSeparator;
abstractSlot : fakeSeparator;
otherTypeMember : fakeSeparator;



// module statements

open : longIdentifier<LONG_IDENTIFIER, LongIdentifier> fakeSeparator;
do : fakeSeparator;

otherModuleMember : fakeSeparator;



// Identifiers

fSharpIdentifier : IDENTIFIER<IDENTIFIER, IdentifierToken>;

longIdentifier: IDENTIFIER<IDENTIFIER, Identifiers>*;



// Access modifiers

accessModifiers: modifier{ACCESS_MODIFIER, Modifiers}*;

private modifier{ROLE,Getter}
:
  PUBLIC<@ROLE,@Getter> |
  PRIVATE<@ROLE,@Getter> |
  INTERNAL<@ROLE,@Getter>
;



// Attributes

fSharpAttribute : longIdentifier<IDENTIFIER, LongIdentifier>; // todo: add constructor expressions

fakeSeparator : FAKE;