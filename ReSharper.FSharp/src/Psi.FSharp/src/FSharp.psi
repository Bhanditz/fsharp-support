options {
  parserPackage="JetBrains.ReSharper.Psi.FSharp.Gen";
  parserClassName="FSharpParserGenerated";
  psiInterfacePackageName="JetBrains.ReSharper.Psi.FSharp.Tree";
  psiStubsPackageName="JetBrains.ReSharper.Psi.FSharp.Impl.Tree";
  psiStubsBaseClass="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpCompositeElement";
  tokenClassName="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpToken";
  tokenTypePackageName="JetBrains.ReSharper.Psi.FSharp.Parsing";
  tokenTypeClassName="FSharpTokenType";
  parserTargetSubdir="Parsing/FSharp";
  psiInterfacesTargetSubdir="Psi/FSharp";
  psiStubsTargetSubdir="Psi/FSharp/Impl";
  elementTypePrefix="";
  visitorClassName="TreeNodeVisitor";
  visitorMethodSuffix="";
  disableReflection;
  separateHierarchies;
  acceptModifier="";
  visitorSuperClassName="JetBrains.ReSharper.Psi.FSharp.TreeNodeVisitorBase";
  "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
  "leafElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpLeafElement";
  "compositeElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpCompositeElement";
  "psiElementVisitorClassFQName"="JetBrains.ReSharper.Psi.FSharp.Tree.TreeNodeVisitor";
  "unexpectedTokenClassFQName"="Parsing.UnexpectedToken";
  "syntaxErrorClassFQName"="Parsing.SyntaxError";
  "parserGenRuntimePackageName"="Parsing";
  "createTokenElementMethodFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Factory.createTokenElement";
  "visitMethodPrefix"="Visit";
  "lexerClassName"="JetBrains.ReSharper.Psi.FSharp.Parsing.FSharpLexer";
  "psiClassesPrefix"="";
  "psiElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Tree.IFSharpTreeNode";
  customImplPackage="JetBrains.ReSharper.Psi.FSharp.Impl.Tree";
  customInterfacePackage="JetBrains.ReSharper.Psi.FSharp.Tree";
  "interfaceNamePrefix"="I";
  "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
  "customImplSuffix"="";
  "objectClassFQName"="System.Object";
  publicChildRolePrefix="FS_";
  tokenBitsetThreshold=4;
  elementTypeBaseClass="JetBrains.ReSharper.Psi.FSharp.Tree.FSharpCompositeNodeType";
  parserMessagesClass="JetBrains.ReSharper.Psi.FSharp.Parsing.ParserMessages";
  generateWorkingPsi;
}



// Files

interface fSharpFile options {
  customParseFunction; noInternalParseFunction;
}
:
  fSharpImplFile |
  fSharpSigFile
;

fSharpImplFile options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpFileBase";
}
:
  topLevelModuleOrNamespaceDeclaration<MODULE_OR_NAMESPACE_DECLARATION, Declarations>*
;

fSharpSigFile options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpFileBase";
}
:
  topLevelModuleOrNamespaceDeclaration<MODULE_OR_NAMESPACE_DECLARATION, Declarations>*
;



// Modules and namespaces

interface fSharpDeclaration
:
  moduleLikeDeclaration |
  moduleMemberDeclaration |
  fSharpTypeDeclaration
;

interface moduleLikeDeclaration
:
  topLevelModuleOrNamespaceDeclaration |
  nestedModuleDeclaration
;

interface topLevelModuleOrNamespaceDeclaration
:
  topLevelModuleDeclaration |
  fSharpNamespaceDeclaration
;

fSharpNamespaceDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpDeclarationBase";
}
:
  longIdentifier<LONG_IDENTIFIER, LongIdentifier>
  moduleMember<MODULE_MEMBER, Members>*
;

topLevelModuleDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  longIdentifier<LONG_IDENTIFIER, LongIdentifier>
  moduleMember<MODULE_MEMBER, Members>*
  fakeSeparator
;

moduleOrNamespaceSignature : fakeSeparator;



// Module members

interface moduleMember
:
  moduleMemberDeclaration |
  moduleMemberStatement |
  otherModuleMember
;

interface moduleMemberDeclaration
:
  nestedModuleDeclaration |
  fSharpTypeDeclaration |
  let |
  fSharpModuleAbbreviation |
  otherMemberDeclaration
;

interface moduleMemberStatement
:
  open |
  do
;

interface fSharpTypeDeclaration
:
  fSharpExceptionDeclaration |
  fSharpTypeParametersOwnerDeclaration
;

interface fSharpTypeParametersOwnerDeclaration
:
  fSharpSimpleTypeDeclaration |
  fSharpObjectModelTypeDeclaration
;

interface fSharpSimpleTypeDeclaration
:
  fSharpEnumDeclaration |
  fSharpRecordDeclaration |
  fSharpUnionDeclaration |
  fSharpNotCompiledTypeDeclaration
;

interface fSharpNotCompiledTypeDeclaration
:
  fSharpTypeAbbreviationDeclaration |
  fSharpModuleAbbreviation |
  fSharpAbstractTypeDeclaration |
  fSharpOtherSimpleTypeDeclaration
;

interface fSharpObjectModelTypeDeclaration
:
  fSharpClassDeclaration |
  fSharpInterfaceDeclaration |
  fSharpStructDeclaration |
  fSharpObjectTypeDeclaration
;

nestedModuleDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  moduleMember<MODULE_MEMBER, Members>*
;



// Enums

fSharpEnumDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpEnumMemberDeclaration<ENUM_MEMBER, EnumMembers>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpEnumMemberDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
;



// Records

fSharpRecordDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpFieldDeclaration<RECORD_FIELD, Fields>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpFieldDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
;




// Discriminated unions

fSharpUnionDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpUnionCaseDeclaration<UNION_CASE, UnionCases>* fakeSeparator
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpUnionCaseDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
  fSharpFieldDeclaration<UNION_FIELD, Fields>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;



// Other members

fSharpExceptionDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpTypeAbbreviationDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpModuleAbbreviation options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

let options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
  body<BODY,Body>
;

otherMemberDeclaration
:

  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
;

fSharpOtherSimpleTypeDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpAbstractTypeDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;


// Object model type declarations

fSharpClassDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpInterfaceDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpStructDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

fSharpObjectTypeDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpTypeElementDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  accessModifiers<ACCESS_MODIFIERS, AccessModifiers>
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfTypeDeclaration<TYPE_PARAMETERS, TypeParameters>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*
;

interface fSharpTypeMemberDeclaration
:
  implicitConstructorDeclaration |
  constructorDeclaration |
  typeInherit |
  interfaceImplementation |
  interfaceInherit |
  abstractSlot |
  memberDeclaration |
  typeLetBindings |
  valField |
  autoProperty |

  otherTypeMember
;

interfaceInherit : longIdentifier<LONG_IDENTIFIER, LongIdentifier>;
typeInherit : longIdentifier<LONG_IDENTIFIER, LongIdentifier> fakeSeparator;

interfaceImplementation
:
  longIdentifier<LONG_IDENTIFIER, LongIdentifier>
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>* fakeSeparator
;


otherTypeMember : fakeSeparator;
typeLetBindings : fakeSeparator;

implicitConstructorDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  memberParam<PARAMETER, Parameters>* fakeSeparator
;

constructorDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  localDeclaration<PARAMETER, Parameters>* fakeSeparator
  NEW<NEW, NewKeyword>
;



// todo: fix properties with explicit setters

memberDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfMethodDeclaration<TYPE_PARAMETER, TypeParameters>*
  memberParam<PARAMETER, Parameters>* fakeSeparator
;

abstractSlot options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
  typeParameterOfMethodDeclaration<TYPE_PARAMETER, TypeParameters>*
  memberParam<PARAMETER, Parameters>* fakeSeparator
;

valField options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
;

autoProperty options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpProperTypeMemberDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
;

memberParam: fakeSeparator;


// module statements

open : longIdentifier<LONG_IDENTIFIER, LongIdentifier>;
do : fakeSeparator;

otherModuleMember : fakeSeparator;



// Identifiers

fSharpIdentifier : IDENTIFIER<IDENTIFIER, IdentifierToken>;

longIdentifier: IDENTIFIER<IDENTIFIER, Identifiers>*;



// Type parameters declarations

typeParameterOfTypeDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
;

typeParameterOfMethodDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
;


// Access modifiers

accessModifiers: modifier{ACCESS_MODIFIER, Modifiers}*;

private modifier{ROLE,Getter}
:
  PUBLIC<@ROLE,@Getter> |
  PRIVATE<@ROLE,@Getter> |
  INTERNAL<@ROLE,@Getter>
;



// Attributes

fSharpAttribute
:
  longIdentifier<IDENTIFIER, LongIdentifier>
  argExpression<ARG_EXPRESSION, ArgExpression>
;

argExpression
:
  longIdentifier<LONG_IDENTIFIER, LongIdentifier>
  STRING<STRING, String>
;
// todo: cover more cases (this is a temp mock for the only case we actually look at it now)


fakeSeparator : FAKE;



// Local declarations

body: fakeSeparator;

localDeclaration options {
  stubBase="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpDeclarationBase";
}
:
  fSharpAttribute<ATTRIBUTE, Attributes>*
  fSharpIdentifier<IDENTIFIER, Identifier>
;
